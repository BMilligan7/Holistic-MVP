<context>
# Product Requirements Document: Holistic MVP

## 1. Overview

Holistic MVP is a web application designed to provide users with hyper-personalized and adaptive wellness plans (covering exercise, nutrition, and sleep) generated by AI. It addresses the complexity of existing AI planners and the lack of deep personalization and real-time adaptability in current wellness coaching (human or AI). The target audience includes individuals seeking general health improvement and athletes aiming for optimal performance. The core value is providing actionable, easy-to-digest, AI-driven guidance that adapts to the user's progress and feedback, fostering consistency and better outcomes.

## 2. Core Features (MVP)

*   **F1: User Authentication & Profile Management**
    *   **What:** Allow users to sign up, log in using username/password, and manage basic profile settings.
    *   **Why:** Essential for personalization and tracking progress over time.
    *   **How:** Utilize Supabase Auth for authentication. Create a dedicated user profile table in Supabase. Implement secure login/signup forms and a basic settings page UI.
*   **F2: Adaptive Onboarding Quiz**
    *   **What:** A multi-step, wizard-style questionnaire to gather initial user data.
    *   **Why:** Collects foundational information (goals, preferences, current state) for initial plan personalization.
    *   **How:** Frontend wizard UI showing one question at a time (~7 core questions, mix of MCQ/Open-ended). AI backend processes answers, potentially asking dynamic follow-up questions based on responses via API calls. Store collected data in the user's profile.
*   **F3: Personalized Plan Generation**
    *   **What:** AI generates initial personalized plans covering Exercise, Nutrition, and Sleep.
    *   **Why:** Provides the core value proposition â€“ a tailored wellness roadmap.
    *   **How:** Backend AI service (using closed-source API model like Claude/GPT/Gemini via prompt engineering) takes user profile data (goals, preferences, constraints, current state) as input. Generates structured plan content for each section. Plans are stored and associated with the user.
*   **F4: Interactive Plan Display**
    *   **What:** Display the generated Exercise, Nutrition, and Sleep plans to the user.
    *   **Why:** Allows users to view and understand their roadmap.
    *   **How:** Single frontend page using tabs or accordions to display each plan section clearly. Content is fetched from the user's stored plan data. (No chatbot interaction directly on this page for MVP).
*   **F5: AI Chatbot Coach**
    *   **What:** An AI assistant for user interaction, questions, updates, and plan adjustments, accessible from the dashboard.
    *   **Why:** Provides ongoing support, facilitates plan adaptation, and enables continuous learning about the user.
    *   **How:** Frontend chat interface (button prominently displayed at the top of the dashboard). Backend AI service handles conversational logic, retains chat history, answers wellness questions, logs user-provided info (meals, mood, etc.), and handles plan update requests based on the Agent/Ask model.
*   **F6: Agent/Ask Plan Update Model**
    *   **What:** User-configurable setting determining how the chatbot handles plan updates (automatic changes, suggested changes, or discussion only).
    *   **Why:** Gives users control over AI autonomy.
    *   **How:** User setting stored in profile (managed via Settings Page). Chatbot backend logic branches based on this setting when adaptation triggers occur or updates are discussed.
*   **F7: Daily Task Generation & Tracking**
    *   **What:** AI translates the high-level plans into specific, actionable daily tasks. Users can mark tasks as complete.
    *   **Why:** Breaks down goals into manageable steps, promoting daily engagement and consistency.
    *   **How:** Backend AI service generates daily tasks based on the user's current plan and task generation rules (actionable, specific, daily scope, plan-linked, varied, user-adapted). Tasks are displayed on the dashboard UI below the chatbot button. User interactions (checking off tasks) update task status in the database.
*   **F8: Progressive Profiling & Micro-Surveys**
    *   **What:** Chatbot proactively asks targeted questions to gather more user data over time.
    *   **Why:** Continuously refines the user profile for better personalization and plan adaptation.
    *   **How:** Backend logic monitors triggers (time-based e.g., weekly, 3 days post-onboarding; event-based e.g., 5 tasks completed; contextual). When triggered, a question is visually indicated within the chatbot button UI on the dashboard. Clicking the button opens chat focused on the question. User response via chat is processed and stored in the user profile (`micro_surveys` table and potentially updates `profiles`).
*   **F9: Basic Progress Tracking Dashboard**
    *   **What:** A simple visual overview of user progress, displayed below tasks on the dashboard.
    *   **Why:** Provides users with feedback and motivation.
    *   **How:** Dashboard UI displaying basic line charts for 1-2 key metrics (derived from logged data or user goals) and streak/count visuals for task completion. Data fetched from user's task history and logged data.
*   **F10: Analytics & Passive Tracking**
    *   **What:** Collect key user interaction data.
    *   **Why:** Understand user behavior, measure feature engagement, identify friction points, and provide implicit personalization cues.
    *   **How:** Implement event tracking for specified actions (onboarding steps, plan views, chat usage, task completion, etc.). Use Supabase Functions to send data to an analytics platform (Mixpanel or Amplitude recommended). Track passive metrics like time on page, click patterns.

## 3. User Experience

*   **User Personas:**
    *   *Health Improver:* Busy professional (25-45) seeking structured guidance to improve general fitness, sleep, and eating habits but overwhelmed by information.
    *   *Performance Seeker:* Amateur athlete (18-35) wanting optimized, adaptive plans for a specific sport/goal, leveraging AI for an edge.
*   **Key User Flows:**
    1.  **Signup & Onboarding:** New User -> Landing Page -> Signup -> Onboarding Quiz -> Initial Plan Generation -> Dashboard.
    2.  **Daily Check-in:** Returning User -> Login -> View Dashboard (Chatbot state/button, Tasks, Progress) -> Complete Tasks -> Optionally Interact with Chatbot.
    3.  **Plan Review & Update:** User -> View Plan Page -> Navigate back to Dashboard -> Interact with Chatbot (triggering Agent/Ask flow) -> Plan Adapted -> View Updated Plan/Tasks.
    4.  **Micro-Survey Interaction:** User -> Sees Question in Chatbot Button -> Clicks Button -> Answers Question in Chat -> Profile Updated.
    5.  **Settings Management:** User -> Navigate to Settings Page -> Update Profile Info/Agent-Ask Preference -> Save Changes.
*   **UI/UX Considerations:**
    *   Clean, intuitive, and encouraging interface.
    *   Minimize friction, especially in onboarding and task tracking.
    *   Clear visual hierarchy on the dashboard (Chat Button > Tasks > Progress).
    *   Wizard style for onboarding; Tabs/Accordions for plan display on its dedicated page.
    *   Chatbot interaction should feel natural and supportive.
    *   Visual feedback for actions (task completion, data logging, settings saved).
    *   Clear indication on chatbot button when a micro-survey is pending.

</context>
<PRD>
## 4. Technical Architecture

*   **Frontend:** React (using Vite or Create React App), `react-router-dom` for routing, Zustand or Context API for state management, `@supabase/supabase-js` for Supabase interaction, `TanStack Query (React Query)` for data fetching/caching, a UI component library (e.g., Tailwind CSS + Headless UI, or Chakra UI), a charting library (e.g., `Recharts`).
*   **Backend:** Supabase (Database, Auth, Edge/Serverless Functions).
*   **Backend Logic (Node.js/TypeScript):** Supabase Functions written in Node.js/TypeScript to handle:
    *   AI interactions (calling external APIs like Anthropic/OpenAI/Google Gemini).
    *   Plan generation logic (prompt engineering).
    *   Task generation logic.
    *   Chatbot conversation management.
    *   Processing onboarding data.
    *   Handling micro-survey triggers and responses.
    *   Saving/updating user profiles, plans, tasks, chat history.
    *   Sending events to external analytics platform.
    *   Handling profile updates from settings page.
*   **AI Model:** External closed-source LLM API (e.g., Claude 3 Sonnet/Haiku, GPT-4o-mini, Gemini 1.5 Pro/Flash) accessed via backend functions. Focus on prompt engineering, no fine-tuning for MVP.
*   **Database (Supabase Postgres):**
    *   `users` (from Supabase Auth, linked to profiles via UUID)
    *   `profiles` (user_id [FK to auth.users], username, agent_ask_preference [enum], plan_structure_preference [enum], primary_wellness_goal [text], specific_measurable_goals [JSONB], fitness_level [enum], sleep_quality [int], avg_sleep_hours [float], stress_level [int], dietary_habits_summary [text], exercise_frequency [enum], exercise_types_enjoyed [text[]], exercise_types_disliked [text[]], time_availability_weekdays [float], time_availability_weekends [float], equipment_access [text[]], preferred_workout_time [enum], dietary_restrictions [text[]], allergies [text[]], created_at, updated_at)
    *   `plans` (plan_id, user_id [FK], plan_type [enum: exercise, nutrition, sleep], content [JSONB], version [int], created_at, updated_at)
    *   `daily_tasks` (task_id, user_id [FK], description [text], status [enum: pending, done, skipped], due_date [date], completed_at [timestamp with time zone], related_plan_id [FK, nullable])
    *   `chat_messages` (message_id, user_id [FK], sender_type [enum: user, ai], content [text], created_at)
    *   `micro_surveys` (survey_id, user_id [FK], question [text], answer [text], created_at)
    *   `logged_data` (log_id, user_id [FK], type [enum: meal, workout, sleep, mood, note], details [JSONB], created_at)
*   **Analytics:** Mixpanel or Amplitude (receiving data from Supabase Functions).
*   **Infrastructure:** Hosted on Supabase platform. Vercel/Netlify for frontend hosting.

## 5. Development Roadmap (MVP Scope)

*(Focus is on what needs to be built, not timelines. Phases represent logical groupings, not necessarily sprints.)*

1.  **Phase 1: Foundation & Core Setup**
    *   Setup Supabase project (DB, Auth).
    *   Setup React frontend project (Vite/CRA, routing, Supabase client).
    *   Setup Supabase Functions environment (Node.js/TS).
    *   Implement basic User Authentication (Signup, Login forms using Supabase Auth UI/logic).
    *   Define and migrate initial database schema for `users` and `profiles`.
    *   Create basic Settings Page UI connected to profile data (read/write basic fields like username).
2.  **Phase 2: Onboarding & Initial Profile**
    *   Implement Onboarding Quiz UI (wizard).
    *   Develop Supabase Function for processing onboarding answers (including potential dynamic AI follow-ups via LLM API).
    *   Save onboarding data to `profiles` table.
3.  **Phase 3: Plan Generation & Display**
    *   Develop Supabase Function for Initial Plan Generation (Exercise, Nutrition, Sleep) using external LLM API and profile data.
    *   Define schema and implement saving plans to `plans` table.
    *   Implement Plan Display UI (single page, tabs/accordions). Fetch and display user's plan data.
4.  **Phase 4: Daily Tasks & Dashboard Core**
    *   Develop Supabase Function for Daily Task Generation based on plans and rules (using LLM API).
    *   Define schema and implement saving tasks to `daily_tasks` table.
    *   Implement core Dashboard UI (layout: Chat button placeholder, Tasks list, Progress placeholder).
    *   Display daily tasks on the dashboard. Implement task completion interaction.
5.  **Phase 5: Chatbot & Basic Interaction**
    *   Implement Chatbot UI (button on dashboard -> opens chat interface).
    *   Develop Supabase Function for basic chat handling (sending messages to LLM API, receiving responses).
    *   Define schema and implement saving chat history to `chat_messages` table.
    *   Implement basic data logging via chat -> save to `logged_data` table.
6.  **Phase 6: Plan Updates & Agent/Ask Model**
    *   Implement UI on Settings page for selecting `agent_ask_preference`.
    *   Enhance Chatbot function to handle plan update requests, respecting the Agent/Ask setting.
    *   Implement logic for AI to suggest/apply plan changes (updating `plans` table, potentially regenerating tasks).
7.  **Phase 7: Progressive Profiling & Micro-Surveys**
    *   Implement trigger logic (time/event based) within backend/Supabase Functions.
    *   Implement UI change for Chatbot button when survey is pending.
    *   Enhance Chatbot function to handle micro-survey presentation and response saving (`micro_surveys` table, update `profiles`).
8.  **Phase 8: Progress Tracking Visuals & Analytics**
    *   Define schema and implement saving/querying relevant data for visuals from `logged_data` and `daily_tasks`.
    *   Implement basic progress visuals on Dashboard (charts, streaks using charting lib).
    *   Setup external Analytics platform (Mixpanel/Amplitude).
    *   Implement Supabase Functions to send tracking events for key user flows and interactions (see Appendix).
9.  **Phase 9: Refinement & Testing Prep**
    *   End-to-end testing of all features.
    *   UI polishing and bug fixing across all flows.
    *   Prepare deployment scripts/processes for frontend and functions.
    *   Develop user testing plan/framework.

## 6. Logical Dependency Chain (Simplified)**

Auth/Profile Setup -> Onboarding Logic & UI -> Plan Generation Logic -> Plan Display UI -> Task Generation Logic -> Task Display UI (Dashboard) -> Chat Basic Logic & UI -> Plan Update Logic (Agent/Ask) -> Micro-Survey Logic & UI -> Progress Visuals -> Analytics Integration.

## 7. Risks and Mitigations

*   **Risk:** AI API Costs exceed budget ($1500 target).
    *   **Mitigation:** Choose cost-effective models (e.g., Claude Haiku, GPT-4o-mini, Gemini Flash). Implement strict usage monitoring, rate limiting. Optimize prompts.
*   **Risk:** AI performance (quality of plans/chat) is insufficient.
    *   **Mitigation:** Intensive prompt engineering. Select capable base models. Clearly define AI limitations. Plan for prompt refinement based on testing.
*   **Risk:** Integration complexity (Supabase Auth + Functions + React + AI API + Analytics).
    *   **Mitigation:** Incremental development and testing phase by phase. Keep MVP features focused. Leverage Supabase documentation and community support.
*   **Risk:** User Engagement/Retention is low during testing.
    *   **Mitigation:** Focus on core value prop (personalized, adaptive plans & tasks). Gather qualitative feedback. Ensure smooth onboarding and actionable tasks. Iterate based on analytics/feedback.
*   **Risk:** Technical feasibility of complex AI interactions within budget/time.
    *   **Mitigation:** Simplify adaptation triggers for MVP. Use Agent/Ask model. Rely on strong prompt engineering over complex custom logic initially.

## 8. Appendix

*   **Out of Scope for MVP:**
    *   Wearable/App Integrations
    *   Push Notifications
    *   Social Features
    *   Advanced Reporting/Analytics Dashboards
    *   Mental Health/Mindfulness or Recovery Plan Sections
    *   AI Fine-tuning
    *   Retrieval-Augmented Generation (RAG)
    *   User-uploaded data sources for AI training
    *   Admin Dashboard
    *   Password Reset Functionality (Consider adding if time permits, otherwise handle manually for testers)
    *   Email Verification (Consider adding if time permits)
*   **Analytics Events (Initial List):** `signup_complete`, `login_success`, `onboarding_step_complete` (prop: step_number), `onboarding_all_complete`, `plan_generated` (prop: plan_type), `plan_section_viewed` (prop: plan_type), `task_generated` (prop: count), `task_completed` (prop: task_id), `chat_opened`, `chat_message_sent` (prop: sender_type), `micro_survey_presented` (prop: survey_id), `micro_survey_answered` (prop: survey_id), `plan_update_requested`, `plan_update_applied` (prop: mode [agent/user]), `settings_saved`, `session_start`, `error_occurred` (prop: details).
*   **Key Data Points:** (Referenced in Technical Architecture Section 4 Database Schema).
</PRD>