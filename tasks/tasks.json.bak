{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Supabase Project and Database Schema",
      "description": "Initialize the Supabase project, configure authentication, and create the database schema for all required tables.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "1. Create a new Supabase project\n2. Configure authentication settings (email/password)\n3. Create database tables according to the schema in the PRD: users, profiles, plans, daily_tasks, chat_messages, micro_surveys, and logged_data\n4. Set up appropriate relationships, constraints, and indexes\n5. Create RLS (Row Level Security) policies for each table to ensure data security\n6. Test database connections and basic CRUD operations\n7. Document the schema and access patterns",
      "testStrategy": "Verify table creation with SQL queries. Test RLS policies by attempting to access data with different user contexts. Validate foreign key constraints and relationships by inserting test data.",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize Supabase Project and Configure Environment",
          "description": "Create a new Supabase project, set up the development environment, and configure the client connection for your application.",
          "dependencies": [],
          "details": "1. Sign up or log in to Supabase dashboard (https://app.supabase.com)\n2. Create a new project with an appropriate name and secure password\n3. Note down the project URL and API keys (anon key and service role key)\n4. Install Supabase client in your application: `npm install @supabase/supabase-js` or equivalent for your framework\n5. Create a configuration file to store Supabase connection details (use environment variables for security)\n6. Initialize the Supabase client in your application:\n```javascript\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabaseUrl = process.env.SUPABASE_URL\nconst supabaseKey = process.env.SUPABASE_ANON_KEY\nconst supabase = createClient(supabaseUrl, supabaseKey)\n```\n7. Test the connection by making a simple query\n\nTesting approach: Verify the connection is working by running a simple query against the default public schema.",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 2,
          "title": "Configure Authentication System",
          "description": "Set up and configure the authentication system in Supabase, including email/password authentication, email templates, and redirect URLs.",
          "dependencies": [
            1
          ],
          "details": "1. Navigate to Authentication > Settings in the Supabase dashboard\n2. Configure site URL and redirect URLs for your application\n3. Enable/disable email confirmations based on your requirements\n4. Customize email templates for confirmation, magic link, and password reset\n5. Configure password policies (minimum length, complexity requirements)\n6. Implement basic authentication functions in your application:\n```javascript\n// Sign up function\nasync function signUp(email, password) {\n  const { data, error } = await supabase.auth.signUp({\n    email,\n    password,\n  })\n  return { data, error }\n}\n\n// Sign in function\nasync function signIn(email, password) {\n  const { data, error } = await supabase.auth.signInWithPassword({\n    email,\n    password,\n  })\n  return { data, error }\n}\n\n// Sign out function\nasync function signOut() {\n  const { error } = await supabase.auth.signOut()\n  return { error }\n}\n```\n7. Test the authentication flow\n\nTesting approach: Create test users and verify the complete authentication flow including signup, email verification (if enabled), login, password reset, and logout.",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 3,
          "title": "Create Core Database Tables and Relationships",
          "description": "Design and implement the core database tables (users, profiles, plans) with appropriate relationships, constraints, and indexes.",
          "dependencies": [
            1
          ],
          "details": "1. Create the users extension table (profiles):\n```sql\nCREATE TABLE profiles (\n  id UUID REFERENCES auth.users(id) PRIMARY KEY,\n  username TEXT UNIQUE,\n  full_name TEXT,\n  avatar_url TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL\n);\n```\n\n2. Create a trigger to automatically create a profile when a user signs up:\n```sql\nCREATE OR REPLACE FUNCTION public.handle_new_user() \nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO public.profiles (id, username, full_name)\n  VALUES (new.id, new.email, new.raw_user_meta_data->>'full_name');\n  RETURN new;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();\n```\n\n3. Create the plans table:\n```sql\nCREATE TABLE plans (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES profiles(id) NOT NULL,\n  title TEXT NOT NULL,\n  description TEXT,\n  start_date DATE NOT NULL,\n  end_date DATE,\n  status TEXT NOT NULL CHECK (status IN ('active', 'completed', 'abandoned')),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL\n);\n\nCREATE INDEX idx_plans_user_id ON plans(user_id);\nCREATE INDEX idx_plans_status ON plans(status);\n```\n\n4. Add updated_at triggers for automatic timestamp updates:\n```sql\nCREATE OR REPLACE FUNCTION update_modified_column()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER update_profiles_modtime\n  BEFORE UPDATE ON profiles\n  FOR EACH ROW EXECUTE PROCEDURE update_modified_column();\n\nCREATE TRIGGER update_plans_modtime\n  BEFORE UPDATE ON plans\n  FOR EACH ROW EXECUTE PROCEDURE update_modified_column();\n```\n\nTesting approach: Insert test data into each table and verify relationships work correctly. Test foreign key constraints by attempting to delete referenced records.",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 4,
          "title": "Create Supporting Database Tables and Relationships",
          "description": "Design and implement the supporting database tables (daily_tasks, chat_messages, micro_surveys, logged_data) with appropriate relationships, constraints, and indexes.",
          "dependencies": [
            3
          ],
          "details": "1. Create the daily_tasks table:\n```sql\nCREATE TABLE daily_tasks (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  plan_id UUID REFERENCES plans(id) ON DELETE CASCADE NOT NULL,\n  title TEXT NOT NULL,\n  description TEXT,\n  due_date DATE,\n  status TEXT NOT NULL CHECK (status IN ('pending', 'completed', 'skipped')),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL\n);\n\nCREATE INDEX idx_daily_tasks_plan_id ON daily_tasks(plan_id);\nCREATE INDEX idx_daily_tasks_status ON daily_tasks(status);\nCREATE INDEX idx_daily_tasks_due_date ON daily_tasks(due_date);\n```\n\n2. Create the chat_messages table:\n```sql\nCREATE TABLE chat_messages (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES profiles(id) NOT NULL,\n  content TEXT NOT NULL,\n  is_from_assistant BOOLEAN NOT NULL DEFAULT false,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL\n);\n\nCREATE INDEX idx_chat_messages_user_id ON chat_messages(user_id);\nCREATE INDEX idx_chat_messages_created_at ON chat_messages(created_at);\n```\n\n3. Create the micro_surveys table:\n```sql\nCREATE TABLE micro_surveys (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES profiles(id) NOT NULL,\n  question TEXT NOT NULL,\n  response TEXT,\n  response_date TIMESTAMP WITH TIME ZONE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL\n);\n\nCREATE INDEX idx_micro_surveys_user_id ON micro_surveys(user_id);\n```\n\n4. Create the logged_data table:\n```sql\nCREATE TABLE logged_data (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES profiles(id) NOT NULL,\n  data_type TEXT NOT NULL,\n  data_value JSONB NOT NULL,\n  logged_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL\n);\n\nCREATE INDEX idx_logged_data_user_id ON logged_data(user_id);\nCREATE INDEX idx_logged_data_data_type ON logged_data(data_type);\nCREATE INDEX idx_logged_data_logged_at ON logged_data(logged_at);\n```\n\n5. Add updated_at triggers for all tables:\n```sql\nCREATE TRIGGER update_daily_tasks_modtime\n  BEFORE UPDATE ON daily_tasks\n  FOR EACH ROW EXECUTE PROCEDURE update_modified_column();\n```\n\nTesting approach: Insert test data into each table and verify relationships work correctly. Test cascading deletes and constraints by performing various operations on related records.",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 5,
          "title": "Implement Row Level Security Policies",
          "description": "Configure Row Level Security (RLS) policies for all tables to ensure proper data access control and security.",
          "dependencies": [
            3,
            4
          ],
          "details": "1. Enable RLS on all tables:\n```sql\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nALTER TABLE plans ENABLE ROW LEVEL SECURITY;\nALTER TABLE daily_tasks ENABLE ROW LEVEL SECURITY;\nALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;\nALTER TABLE micro_surveys ENABLE ROW LEVEL SECURITY;\nALTER TABLE logged_data ENABLE ROW LEVEL SECURITY;\n```\n\n2. Create RLS policies for profiles table:\n```sql\n-- Users can view any profile\nCREATE POLICY \"Profiles are viewable by everyone\" \nON profiles FOR SELECT USING (true);\n\n-- Users can only update their own profile\nCREATE POLICY \"Users can update their own profile\" \nON profiles FOR UPDATE USING (auth.uid() = id);\n```\n\n3. Create RLS policies for plans table:\n```sql\n-- Users can view only their own plans\nCREATE POLICY \"Users can view their own plans\" \nON plans FOR SELECT USING (auth.uid() = user_id);\n\n-- Users can insert their own plans\nCREATE POLICY \"Users can insert their own plans\" \nON plans FOR INSERT WITH CHECK (auth.uid() = user_id);\n\n-- Users can update their own plans\nCREATE POLICY \"Users can update their own plans\" \nON plans FOR UPDATE USING (auth.uid() = user_id);\n\n-- Users can delete their own plans\nCREATE POLICY \"Users can delete their own plans\" \nON plans FOR DELETE USING (auth.uid() = user_id);\n```\n\n4. Create similar RLS policies for all other tables (daily_tasks, chat_messages, micro_surveys, logged_data) following the same pattern of restricting access to the user's own data.\n\n5. For tables with relationships (like daily_tasks), create policies that join to the parent table:\n```sql\n-- Users can view their own daily tasks\nCREATE POLICY \"Users can view their own daily tasks\" \nON daily_tasks FOR SELECT \nUSING (\n  auth.uid() IN (\n    SELECT user_id FROM plans WHERE id = daily_tasks.plan_id\n  )\n);\n```\n\nTesting approach: Test RLS policies by creating multiple test users and verifying that each user can only access their own data. Test with both the anon key and service role key to ensure policies are working correctly.",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 6,
          "title": "Test Database Operations and Document Schema",
          "description": "Test CRUD operations on all tables, verify RLS policies are working correctly, and create comprehensive documentation for the database schema and access patterns.",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "1. Create a test script to verify CRUD operations on all tables:\n```javascript\nasync function testDatabaseOperations() {\n  // Test user authentication\n  const { data: authData, error: authError } = await supabase.auth.signUp({\n    email: 'test@example.com',\n    password: 'password123'\n  })\n  \n  // Test profile operations\n  const { data: profileData, error: profileError } = await supabase\n    .from('profiles')\n    .select('*')\n    .eq('id', authData.user.id)\n    .single()\n  \n  // Test plan operations\n  const { data: planData, error: planError } = await supabase\n    .from('plans')\n    .insert([\n      { \n        user_id: authData.user.id,\n        title: 'Test Plan',\n        description: 'Test Description',\n        start_date: new Date().toISOString().split('T')[0],\n        status: 'active'\n      }\n    ])\n    .select()\n  \n  // Continue with tests for other tables...\n}\n```\n\n2. Test RLS policies by attempting unauthorized access:\n```javascript\nasync function testRLSPolicies() {\n  // Create two test users\n  const { data: user1 } = await supabase.auth.signUp({...})\n  const { data: user2 } = await supabase.auth.signUp({...})\n  \n  // Create data for user1\n  await supabase.auth.setSession(user1.session)\n  const { data: plan1 } = await supabase.from('plans').insert([...])\n  \n  // Try to access user1's data as user2\n  await supabase.auth.setSession(user2.session)\n  const { data, error } = await supabase\n    .from('plans')\n    .select('*')\n    .eq('id', plan1[0].id)\n  \n  // Should return empty array or error due to RLS\n  console.log(data, error)\n}\n```\n\n3. Create comprehensive schema documentation:\n   - Create an Entity-Relationship Diagram (ERD) using a tool like dbdiagram.io or Lucidchart\n   - Document each table's purpose, columns, constraints, and relationships\n   - Document RLS policies and access patterns\n   - Document common queries and operations\n   - Include examples of how to perform CRUD operations on each table\n\n4. Create a database migration script or use Supabase migrations:\n```bash\nnpx supabase migration new initial_schema\n```\n\n5. Document the authentication flow and how it integrates with the database schema\n\nTesting approach: Run comprehensive tests on all tables and relationships. Verify that RLS policies correctly restrict access. Test edge cases like cascading deletes and constraint violations.",
          "status": "done",
          "parentTaskId": 1
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement User Authentication and Profile Management",
      "description": "Create the frontend authentication flow and profile management functionality using Supabase Auth.",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "1. Set up React project with Vite\n2. Install required dependencies: react-router-dom, @supabase/supabase-js, TanStack Query, and UI library (Tailwind CSS + Headless UI)\n3. Create authentication components (SignUp, Login forms)\n4. Implement protected routes using react-router-dom\n5. Create a Settings page for profile management\n6. Connect authentication components to Supabase Auth\n7. Implement profile data fetching and updating functionality\n8. Add form validation and error handling",
      "testStrategy": "Test user registration, login, and logout flows. Verify that protected routes redirect unauthenticated users. Ensure profile data is correctly saved and retrieved from the database.",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Develop Onboarding Quiz Wizard",
      "description": "Create the multi-step onboarding questionnaire to gather initial user data for personalization.",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "1. Design the wizard UI with step indicators and navigation controls\n2. Create ~7 core questions mixing MCQ and open-ended formats\n3. Implement state management for the wizard using Zustand or Context API\n4. Set up Supabase Function for processing onboarding answers\n5. Integrate with external LLM API (Claude/GPT/Gemini) for potential dynamic follow-up questions\n6. Store collected data in the user's profile\n7. Implement progress saving to allow users to continue later\n8. Add validation for required fields",
      "testStrategy": "Test the wizard flow with various input combinations. Verify data is correctly saved to the profile. Test the dynamic follow-up question functionality with different initial responses."
    },
    {
      "id": 4,
      "title": "Implement Plan Generation Logic",
      "description": "Develop the backend logic to generate personalized wellness plans using AI based on user profile data.",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "1. Set up Supabase Functions environment with Node.js/TypeScript\n2. Create a function to process user profile data for AI consumption\n3. Develop prompt engineering for the external LLM API (Claude/GPT/Gemini)\n4. Implement plan generation logic for Exercise, Nutrition, and Sleep sections\n5. Structure the AI responses into consistent JSON format\n6. Save generated plans to the plans table with appropriate metadata\n7. Implement error handling and retry logic for API failures\n8. Add logging for monitoring API usage and costs",
      "testStrategy": "Test plan generation with various user profiles. Verify the structure and quality of generated plans. Monitor API usage and costs. Test error handling by simulating API failures."
    },
    {
      "id": 5,
      "title": "Create Plan Display UI",
      "description": "Develop the interface for displaying the generated wellness plans to users.",
      "status": "pending",
      "dependencies": [
        4
      ],
      "priority": "medium",
      "details": "1. Design a clean, intuitive UI for plan display using tabs or accordions\n2. Create components for each plan section (Exercise, Nutrition, Sleep)\n3. Implement data fetching from the plans table using TanStack Query\n4. Add loading states and error handling\n5. Create a responsive layout that works well on different devices\n6. Implement navigation between plan sections\n7. Add visual indicators for plan version/updates\n8. Ensure accessibility compliance",
      "testStrategy": "Test the UI on different screen sizes. Verify that all plan sections are correctly displayed. Test loading states and error handling. Conduct accessibility testing."
    },
    {
      "id": 6,
      "title": "Implement Daily Task Generation and Display",
      "description": "Create the logic to generate actionable daily tasks from plans and display them on the dashboard.",
      "status": "pending",
      "dependencies": [
        4,
        5
      ],
      "priority": "high",
      "details": "1. Develop Supabase Function for daily task generation based on plans\n2. Implement prompt engineering for the LLM to create specific, actionable tasks\n3. Save generated tasks to the daily_tasks table\n4. Create the dashboard UI layout with task list section\n5. Implement task display components with completion checkboxes\n6. Add task completion functionality that updates the database\n7. Implement task filtering (e.g., by date, by plan type)\n8. Add visual feedback for task completion",
      "testStrategy": "Test task generation with different plan types. Verify tasks are specific and actionable. Test task completion functionality. Verify database updates when tasks are completed."
    },
    {
      "id": 7,
      "title": "Develop AI Chatbot Coach",
      "description": "Create the chatbot interface and backend logic for user interaction and support.",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "1. Design the chat interface with a prominent button on the dashboard\n2. Implement the chat UI with message history display\n3. Create Supabase Function for handling chat interactions with the LLM API\n4. Implement chat history storage in the chat_messages table\n5. Add context management to provide the AI with relevant user data\n6. Implement basic data logging via chat (meals, mood, etc.)\n7. Create typing indicators and loading states\n8. Add error handling and fallback responses",
      "testStrategy": "Test chat interactions with various queries. Verify chat history is correctly saved and displayed. Test data logging functionality. Verify context management by checking if the AI references previous interactions."
    },
    {
      "id": 8,
      "title": "Implement Agent/Ask Model and Plan Updates",
      "description": "Create the functionality for users to control how the AI handles plan updates and implement the plan update logic.",
      "status": "pending",
      "dependencies": [
        7
      ],
      "priority": "medium",
      "details": "1. Add Agent/Ask preference setting to the Settings page UI\n2. Update the profile schema to store this preference\n3. Enhance the chatbot function to respect the Agent/Ask setting\n4. Implement logic for the AI to suggest plan changes\n5. Create functionality to apply plan updates (updating plans table)\n6. Implement task regeneration after plan updates\n7. Add notifications or visual indicators for plan changes\n8. Create a history of plan versions",
      "testStrategy": "Test all three Agent/Ask modes (automatic changes, suggested changes, discussion only). Verify plan updates are correctly applied to the database. Test task regeneration after plan updates."
    },
    {
      "id": 9,
      "title": "Develop Progressive Profiling and Micro-Surveys",
      "description": "Implement the system for gathering additional user data over time through targeted questions.",
      "status": "pending",
      "dependencies": [
        7,
        8
      ],
      "priority": "low",
      "details": "1. Implement trigger logic for micro-surveys (time-based, event-based, contextual)\n2. Create UI indicator on the chatbot button when a survey is pending\n3. Enhance the chatbot to present surveys and process responses\n4. Save survey responses to the micro_surveys table\n5. Update the user profile with new information\n6. Implement logic to avoid repetitive questions\n7. Create a backlog of potential questions for different contexts\n8. Add analytics tracking for survey completion",
      "testStrategy": "Test different trigger types for micro-surveys. Verify survey responses are correctly saved and profile data is updated. Test the UI indicator for pending surveys."
    },
    {
      "id": 10,
      "title": "Implement Progress Tracking and Analytics",
      "description": "Create the progress visualization components and set up analytics tracking for user interactions.",
      "status": "pending",
      "dependencies": [
        6,
        9
      ],
      "priority": "low",
      "details": "1. Install and configure a charting library (Recharts)\n2. Implement basic line charts for key metrics\n3. Create streak/count visuals for task completion\n4. Add data aggregation logic for the visualizations\n5. Set up external analytics platform (Mixpanel or Amplitude)\n6. Implement Supabase Functions to send tracking events\n7. Add event tracking for all key user interactions listed in the PRD\n8. Create a dashboard component to display the progress visuals\n9. Implement responsive design for the visualizations",
      "testStrategy": "Test data visualization with different datasets. Verify analytics events are correctly sent to the external platform. Test the responsiveness of the visualizations on different screen sizes."
    }
  ],
  "metadata": {
    "projectName": "Holistic MVP Implementation",
    "totalTasks": 10,
    "sourceFile": "scripts/prd.txt",
    "generatedAt": "2023-07-10"
  }
}